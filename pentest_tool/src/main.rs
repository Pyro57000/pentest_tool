use std::fs;
use std::io::Write;
use std::path::PathBuf;
use std::process;
use std::time;
use std::time::Duration;
use std::time::SystemTime;
use clearscreen::clear;
use directories::UserDirs;
use clearscreen;

#[derive(Clone)]
struct Project{
    customer: String,
    project_name: String,
    notes_folder: PathBuf,
    files_folder: PathBuf,
    activativation_time: SystemTime,
    hour_count: Duration,
    active: bool,
    boxname: String,
    id: i32,
} 



fn install(config_path: &PathBuf){
    let mut config_folder_path: PathBuf = config_path.clone();
    config_folder_path.pop();
    let mut projects_conf_path = config_folder_path.clone();
    projects_conf_path.push("projects.conf");
    fs::create_dir_all(config_folder_path).expect("error creating config dir");
    let mut config_file = fs::File::create(config_path).expect("error creating file");
    let mut projects_conf_file = fs::File::create(projects_conf_path).expect("error creating projects config file");
    projects_conf_file.write_all(b"customer:name:time").expect("error writing default project info");
    let mut notes_response = String::new();
    let mut files_response = String::new();
    let mut tools_response = String::new();
    println!("path to save project notes?");
    std::io::stdin().read_line(&mut notes_response).unwrap();
    println!("path to save project files?");
    std::io::stdin().read_line(&mut files_response).unwrap();
    println!("path to folder with your custom tools?");
    std::io::stdin().read_line(&mut tools_response).unwrap();
    let config_string = format!("Project_files:{}\nProject_notes:{}\ntools:{}", files_response.trim_end(), notes_response.trim_end(), tools_response.trim_end());
    config_file.write_all(config_string.as_bytes()).expect("error writing to config file");
    println!("config file generated and saved to {}\n", config_path.display());
    println!("please make sure to install distrobox:\nhttps://github.com/89luca89/distrobox\n\nthis will require either docker or podman as well.\n\n");
    println!("please rerun the program");
    std::process::exit(1);
}


fn get_projects(base_notes: &PathBuf, base_files: &PathBuf, config_path: &mut PathBuf) -> Vec<Project>{
    config_path.pop();
    config_path.push("projects.conf");
    let mut projects = Vec::new();
    let projects_string = fs::read_to_string(config_path).expect("error reading projects file");
    let project_lines:Vec<&str> = projects_string.split("\n").collect();
    let mut first = 0;
    for line in project_lines{
        first = first + 1;
        if first != 1{
            if line.len() > 1{
                let settings: Vec<&str> = line.split(":").collect();
                let customer = settings[0].to_owned();
                let project = settings[1].to_owned();
                let folder_name = format!("{}/{}", customer, project);
                let mut notes_folder = base_notes.clone();
                let mut project_folder = base_files.clone();
                notes_folder.push(&folder_name);
                project_folder.push(&folder_name);
                let hours_count:u64 = settings[3].trim_end().parse().expect("error converting to u64");
                let _mins_count = hours_count * 60;
                let secs_count = hours_count * 60;
                let hours = Duration::from_secs(secs_count); 
                let mut active = false;
                if settings[2] == "yes"{
                    active = true;
                }
                let time = SystemTime::now();
                let boxname = settings[4].to_owned();
                let new_project = Project{customer: customer, project_name: project, files_folder: project_folder, notes_folder: notes_folder, activativation_time: time, hour_count: hours, active: active, id: first, boxname: boxname};
                println!("{} {} LOADED!", &new_project.customer, &new_project.project_name);
                projects.push(new_project);
            }
        }
    }
    return projects
}


fn switch_project(projects: &mut Vec<Project>, config_path: &PathBuf){
    for project in projects.clone(){
        if project.active == false{
            println!("{} {}|{}", project.id, project.customer, project.project_name);
        }
    }
    println!("\nnew project selection?\n");
    let mut response = String::new();
    std::io::stdin().read_line(&mut response).unwrap();
    if response.len() > 1{
        let new_id:i32 = response.trim_end().parse().expect("error converting to i32");
        for project in projects{
            if project.id ==  new_id{
                project.active = true;
                println!("project found switching to {} {}", project.customer, project.project_name);
                let mut box_selection_path = config_path.clone();
                box_selection_path.pop();
                box_selection_path.pop();
                box_selection_path.push("current_box");
                let mut box_selection = fs::File::create(box_selection_path).expect("error opening up box selection file");
                let box_output = project.boxname.as_bytes();
                box_selection.write_all(box_output).expect("error writing new box");
            }
            else if project.id != new_id{
                project.active = false;
            }
            else{
                println!("error unknown project id")
            }
        }
    }
    else{
        println!("error we need user input here dummy!");
    }
    
}

fn save_projects(projects: &Vec<Project>, config_path: &PathBuf){
   let mut save_file_path = config_path.clone();
    save_file_path.pop();
    save_file_path.push("projects.conf");
    let mut save_file = fs::File::create(save_file_path).expect("error creating save_file");
    save_file.write_all(b"customer:name:active:hours:box_name\n").expect("error writing first line to file");
    for project in projects{
        let default = format!{"{}:{}:", project.customer, project.project_name};
        let mut _outline = String::new();
        if project.active{
            let hours = project.hour_count.as_secs()/60 + time::SystemTime::now().duration_since(project.activativation_time).expect("error caclucating hours").as_secs()/60;
            _outline = format!("{}yes:{}:{}\n", default, hours, project.boxname);
        }
        else{
            _outline = format!("{}no:{}:{}\n", default, project.hour_count.as_secs()/60, project.boxname);
        }
        save_file.write_all(_outline.as_bytes()).expect("error writing outline");
    }
}


fn get_active_project(projects: &Vec<Project>) -> &Project{
    let mut active_project = &projects[0];
    for project in projects{
        if project.active == true{
            active_project = project
        }
    }
    return active_project
}

fn start_pentest(){
    let mut customer_name = String::new();
    let mut project_name = String::new();
    let mut scope = String::new();
    println!("Customer name?");
    std::io::stdin().read_line(&mut customer_name).unwrap();
    println!("Project name?");
    std::io::stdin().read_line(&mut project_name).unwrap();
    println!("path to scope?");
    std::io::stdin().read_line(&mut scope).unwrap();
    scope.pop();
    project_name.pop();
    customer_name.pop();
    let status = process::Command::new("start_pentest")
                                                .arg(scope)
                                                .arg(customer_name)
                                                .arg(project_name)
                                                .status().expect("error spawning start_pentest");
    if status.success() == false{
        println!("error please cleanup and re-run manually");
    }
}

fn new_project(projects: &mut Vec<Project>, project_dir: &PathBuf, notes_dir: &PathBuf, tools_dir: &PathBuf, boxtemplate: &String){
    let mut new_id = 0;
    for project in projects.clone(){
        if project.id > new_id{
            new_id = project.id + 1;
        }
    }
    let mut new_project_dir = project_dir.clone();
    let mut new_note_dir = notes_dir.clone();
    let mut existing_folders = String::new();
    let mut customer_name = String::new();
    let mut project_name = String::new();
    println!("customer name?");
    std::io::stdin().read_line(&mut customer_name).unwrap();
    println!("project name?");
    std::io::stdin().read_line(&mut project_name).unwrap();
    println!("do you have an existing notes and folder structure to copy over?\ny/n");
    std::io::stdin().read_line(&mut existing_folders).unwrap();
    let customer_name = customer_name.trim_end().to_owned();
    let project_name = project_name.trim_end().to_owned();
    new_project_dir.push(&customer_name);
    new_note_dir.push(&customer_name);
    new_project_dir.push(&project_name);
    new_note_dir.push(&project_name);
    if existing_folders.contains("y") || existing_folders.contains("Y"){
        let mut files_to_copy = String::new();
        let mut notes_to_copy = String::new();
        println!("path to project folder folder to copy:");
        std::io::stdin().read_line(&mut files_to_copy).unwrap();
        println!("path to notes folder to copy:");
        std::io::stdin().read_line(&mut notes_to_copy).unwrap();
        files_to_copy.pop();
        notes_to_copy.pop();
        println!("files to copy: {}", files_to_copy);
        println!("notes to copy: {}", notes_to_copy);
        println!("files destination: {}", new_project_dir.display());
        println!("notes destination: {}", new_note_dir.display()); 
        let folder_move_success = process::Command::new("mv")
                                            .arg("-i")
                                            .arg(files_to_copy)
                                            .arg(new_project_dir.display().to_string())
                                            .status().expect("unable to call the system mv command");
        let note_move_success = process::Command::new("mv")
                                            .arg("-i")
                                            .arg(notes_to_copy)
                                            .arg(new_note_dir.display().to_string())
                                            .status().expect("unable to call the system mv command");
        if folder_move_success.success(){
            println!("we copied the project folder correctly!!");
        }
        else{
            println!("failed to copy the project folder, try to move it manually!");
        }
        if note_move_success.success(){
            println!("we copied the notes folder correctly!!");
        }
        else{
            println!("failed to copy the notes folder, try to move it manually!");
        }
     
    }
    else{
        //working_path.push("working"); 
        fs::create_dir_all(&new_project_dir).expect("error creating new files folder");
        fs::create_dir_all(&new_note_dir).expect("error creating new notes folder");
    }
    let box_name = format!("atarchbox_{}", customer_name);
    let pentest_volume = format!("{}:/pentest:rw", new_project_dir.display());
    let toold_volume = format!("{}:/tools:rw", tools_dir.display());
    let distrobox_result = process::Command::new("distrobox")
                                                                .arg("create")
                                                                .arg("--clone")
                                                                .arg(boxtemplate)
                                                                .arg("--init")
                                                                .arg("--volume")
                                                                .arg(toold_volume)
                                                                .arg("--volume")
                                                                .arg(pentest_volume)
                                                                .arg("--name")
                                                                .arg(&box_name)
                                                                .status()
                                                                .expect("error getting distrobox status");
    if distrobox_result.success(){
        println!("we made a distrobox oh boy!");
        let distrobox_start_result = process::Command::new("distrobox")
                                                                        .arg("enter")
                                                                        .arg(&box_name)
                                                                        .status()
                                                                        .expect("error getting response from distrobox start");
        if distrobox_start_result.success(){
            println!("distrobox was started as well!!!! good job me!");
        }
        else{
            println!("ooof did not start successfully try entering it yoruself");
        }
    }
    else{
        println!("ooof distrobox did not work.... try creating it yourself");
    }
    let new_project = Project{customer: customer_name.trim_end().to_owned(), 
                                    project_name: project_name.trim_end().to_owned(), 
                                    notes_folder: new_note_dir, 
                                    files_folder:new_project_dir, 
                                    activativation_time: SystemTime::now(),
                                    hour_count: Duration::new(1, 1),
                                    active: false,
                                    id: new_id,
                                    boxname: box_name,
                                      };
    projects.push(new_project);

}


fn remove_project(projects: &mut Vec<Project>){
    for project in projects.clone(){
        println!("{} {} {}", project.id, project.customer, project.project_name);
    }
    let mut project_to_remove = String::new();
    println!("project to remove?");
    std::io::stdin().read_line(&mut project_to_remove).unwrap();
    let mut project_to_keep = Vec::new();
    if project_to_remove.len() > 0{
        let remove_id: i32 = project_to_remove.trim_end().parse().unwrap();
        let mut project_set = false;
        for project in projects.clone(){
            if project.id == remove_id{
                println!("will remove {} {}", project.customer, project.project_name);
                project_set = true;
                let distrobox_rm_status = process::Command::new("distrobox")
                                                                        .arg("rm")
                                                                        .arg("-f")
                                                                        .arg(project.boxname)
                                                                        .status().expect("error calling distrobox");
                if distrobox_rm_status.success(){
                    println!("Distrobox Removal Successful!!!");
                }
                else{
                    println!("Distrobox Removal Failed, manual removal required!");
                }
            }
            else {
                println!("{} {} will be kept", project.customer, project.project_name);
                project_to_keep.push(project);
            }
        }
        if project_set{
            projects.clear();
            projects.append(&mut project_to_keep);
        }
        else{
            println!("error no prjects found to remove")
        }
        
    }
    else{
        println!("we need user in put here dummy!!");
    }
}
fn open_in_dolphin(folder: &str, project: Project){
    let mut to_open = PathBuf::new();
    match folder{
        "notes" => to_open.push(project.notes_folder),
        "files" => to_open.push(project.files_folder),
        _ => println!("unknown entry... this should literally be impossible... how.... how tf did you.... what")
    }
    process::Command::new("dolphin")
                         .arg(to_open)
                         .spawn().expect("error opening dolphin");
}

fn stop_all_boxes(projects: &Vec<Project>){
    let mut problem_childs: Vec<Project> = Vec::new();
    let mut all_done = true;
    for project in projects{
        let stopped = process::Command::new("distrobox")
                             .arg("stop")
                             .arg(&project.boxname)
                             .status().expect("error spawing distrobox");
        if stopped.success(){
            println!("{} sucessfully stopped!", &project.boxname);
        }
        else{
            println!("{} not stopped!!!!!!!", &project.boxname);
            all_done = false;
            problem_childs.push(project.clone());
        }
    }
    if all_done{
        println!("All boxes stopped GO US YAAAAA WE DID IT");
    }
    else{
        println!("OOOOOOOF some boxes didn't stop yo, that's cringe");
        println!("here are the problem childs, you may need to stop them manually");
        for child in problem_childs{
            println!("{}",child.boxname);
        }
    }
}


fn project_standalone_terminal(){
    process::Command::new("konsole").arg("-e").arg("'~/.config/start_box.sh'").spawn().expect("error opeing konsole");
}


fn project_inline_terminal(project: Project){
    process::Command::new("distrobox").arg("enter").arg(project.boxname).status().expect("error opeing konsole");
}


fn main_menu(mut projects: Vec<Project>, config_path: &PathBuf, base_files: &PathBuf, base_notes: &PathBuf, tools_dir: &PathBuf, boxtemplate: String){
    let mut loopize = true;
    loop {
        let active_project = get_active_project(&projects);
        let mut response = String::new();
        clear().expect("error clearing screen");
        print!("
              ___       __   __         ___               __        ___  __  
        |  | |__  |    /  ` /  \\  |\\/| |__     |__|  /\\  /  ` |__/ |__  |__) 
        |/\\| |___ |___ \\__, \\__/  |  | |___    |  | /~~\\ \\__, |  \\ |___ |  \\ 
                                                                             
         __   ___ ___     __                    __                           
        / _` |__   |     |__) |  | |\\ | | |\\ | / _`                          
        \\__> |___  |     |    |/\\| | \\| | | \\| \\__>     
    


NOTE SAVE PROJECT INFO BEFORE STOPPING THE APPLICATION, OR HOUR TRACKIGN WON'T BE ACCURATE
NOTE OPTION 10 WILL SAVE YOUR PROJECTS BEFORE QUITTING

Current Project: {} {}
Current Minutes: {} minutes

        Main Menu:
            1 .) Show Active Project
            2 .) List Projects
            3 .) Switch Active Project
            4 .) Print Active Project Time
            5 .) Print All Proejct Times
            6 .) create new project with Pyro's default tool
            7 .) Save Project Information
            8 .) Import New Project - and setup new Distrobox
            9 .) Remove Project
            10.) Open A New Terminal in Current Active Project
            11.) Open A Terminal In this windows for the current active project
            12.) Open Project Files Folder In Dolphin
            13.) Open Project Notes Folder In Dolphin
            14.) Stop All Distroboxes
            15.) Quit Application
\n", active_project.customer, active_project.project_name, SystemTime::now().duration_since(active_project.activativation_time).unwrap().as_secs() / 60);
        std::io::stdin().read_line(&mut response).expect("error getting menu input");
        clear().expect("error clearing screen");
        match response.as_str().trim_end(){
            "1" => println!("\n{} {}", active_project.customer ,active_project.project_name),
            "2" => {println!("+++++++++++++++++++++"); 
                    for project in &projects{
                        println!("++{}|{}++",project.customer ,project.project_name)}
                    println!("++++++++++++++++++++")},
            "3" => switch_project(&mut projects, config_path),
            "4" => println!("current Hour Count: {}", active_project.hour_count.as_secs()/3600 + time::SystemTime::now().duration_since(active_project.activativation_time).expect("error caclucating hours").as_secs()/3600),
            "5" => {println!("++++++++++++++++++++");
                    for project in &projects{
                        if project.active == true{
                            println!("++{} {}: {}++", project.customer, project.project_name, project.hour_count.as_secs()/3600 + time::SystemTime::now().duration_since(project.activativation_time).expect("error caclucating hours").as_secs()/3600);
                            }
                        else{
                            println!("++{} {}:{}++", project.customer, project.project_name, project.hour_count.as_secs()/3600);
                        }
                    }
                    println!("++++++++++++++++++++")
                },
            "6" => start_pentest(),
            "7" => save_projects(&projects, &config_path),
            "8" => new_project(&mut projects, &base_files, &base_notes, &tools_dir, &boxtemplate),
            "9" => remove_project(&mut projects),
            "10" => project_standalone_terminal(),
            "11" => project_inline_terminal(active_project.clone()),
            "12" => open_in_dolphin("files", active_project.clone()),
            "13" => open_in_dolphin("notes", active_project.clone()),
            "14" => stop_all_boxes(&projects),
            "15" => {save_projects(&projects, &config_path);
                    let mut stop = String::new(); 
                    println!("stop all boxes?\ny/n");
                    std::io::stdin().read_line(&mut stop).unwrap();
                    if stop.contains("y"){
                        stop_all_boxes(&projects);
                    }
                    loopize = false},
            _ => println!("uknonwn selection")
        }
        if loopize == false{
            break
        }
        println!("\n\n\npress enter to return to the menu");
        let mut enter = String::new();
        std::io::stdin().read_line(&mut enter).unwrap();
    }
}


fn main() {
    print!("
    ⠀⠀⠀⣠⠶⠚⠛⠛⠛⠲⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⣴⠟⠁⠀⠀⠀⠀⠀⠀⠀⠻⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⣠⣾⣷⣄⠀⠀⠀⢀⣠⣤⣤⡀⠀⢿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⢸⣿⡿⢃⣸⡶⠂⢠⣿⣿⡿⠁⣱⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⢸⡏⠉⠩⣏⣐⣦⠀⠛⠦⠴⠚⠁⠀⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⣼⠧⠶⠶⠶⠿⠶⠶⠖⠚⠛⠉⠁⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠶⠶⡄⠀⠀
    ⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⠀⠀⢹⠀⠀
    ⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⢤⢠⡆⠀⢸⡄⠀⠀⠀⠀⠀⠀⢀⡿⠁⠀⠀⡾⠀⠀
    ⢹⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠈⡇⠀⠸⣧⣠⠴⠶⠖⠲⢶⡞⠁⠀⢈⡼⢃⠀⠀
    ⠸⡆⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⡇⠀⠀⢿⠁⠄⣲⡶⠶⠿⢤⣄⡀⠛⢛⠉⢻⠀
    ⠀⢿⡀⠀⠀⠀⠀⠀⠀⠀⢸⠠⣇⠀⠀⠀⠀⠊⠁⠀⠀⠀⠀⠀⠙⢦⠈⠙⠓⣆
    ⠀⠈⢷⡀⠀⠀⠀⠀⠀⢠⠏⡀⣬⣹⣦⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠈⡿⠶⠶⠋
    ⠀⠀⠈⢷⡀⠀⠀⠀⠀⠘⠛⠛⠋⠀⠀⠀⠀⠀⠀⠄⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀
    ⠀⠀⠀⠀⠙⢦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠀⣠⡞⠁⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠀⠈⠛⣷⢶⣦⣤⣄⣀⣠⣤⣤⠀⣶⠶⠶⠶⠛⠁⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⣀⡀⠀⣰⠇⣾⠀⠀⠈⣩⣥⣄⣿⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⢿⡉⠳⡟⣸⠃⠀⠀⠀⠘⢷⣌⠉⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⠙⢦⣴⠏⠀⠀⠀⠀⠀⠀⠉⠳⠶⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
    ");
    let user_dirs = UserDirs::new().expect("error getting user directories");
    let mut config_path = user_dirs.home_dir().to_path_buf();
    config_path.push(".config/pyro_pentest_tool/conf");
    if config_path.as_path().exists() == false{
        install(&config_path);
    }
    let mut project_base_folder = PathBuf::new();
    let mut project_base_notes = PathBuf::new();
    let mut tools_folder = PathBuf::new();
    println!("config already generated\nloading config file...\n");
    let settings_string = fs::read_to_string(&config_path).expect("error reading config file");
    let settings: Vec<&str> = settings_string.split("\n").collect();
    let mut box_template = String::new();
    for line in settings{
        if line.len() > 1{
            let setting_vec: Vec<&str> = line.split(":").collect();
            match setting_vec[0]{
                "Project_files" => project_base_folder.push(setting_vec[1].trim_end()),
                "Project_notes" => project_base_notes.push(setting_vec[1].trim_end()),
                "tools_folder" => tools_folder.push(setting_vec[1].trim_end()),
                "box_template" => box_template = setting_vec[1].trim_end().to_owned(),
                _ => println!("error unknown setting: {}", setting_vec[0])
            }
        }
    }
    print!("
    Project Folders: {} 
    Note Folders: {}
    Tools Folder: {}
    distrobox template: {}\n
", project_base_folder.display(), project_base_notes.display(), tools_folder.display(), box_template);
    println!("loading project configs...");
    let projects = get_projects(&project_base_notes, &project_base_folder, &mut config_path);
    println!("Enter to start main menu");
    let mut enter = String::new();
    std::io::stdin().read_line(&mut enter).unwrap();
    main_menu(projects, &config_path, &project_base_folder, &project_base_notes, &tools_folder, box_template);
}
